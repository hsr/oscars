package net.es.oscars.pss.openflowj.config;

import java.util.ArrayList;
import java.util.List;

import net.es.oscars.api.soap.gen.v06.ResDetails;
import net.es.oscars.pss.beans.PSSAction;
import net.es.oscars.pss.beans.PSSException;
import net.es.oscars.pss.enums.ActionType;
import net.es.oscars.pss.openflowj.util.OFPathTools;
import net.es.oscars.utils.soap.OSCARSServiceException;
import net.es.oscars.utils.topology.NMWGParserUtil;
import net.es.oscars.utils.topology.PathTools;

import org.ogf.schema.network.topology.ctrlplane.CtrlPlaneHopContent;
import org.openflow.protocol.OFMessage;

/**
 * Abstract class used to generate the OpenFlow messages for devices to be configured
 * in 'explicit' mode. Explicit mode is the OpenFlow default. It involves sending
 * a message to each router in the path with the required flow information. Most
 * new implementations will be children of this class that implement their own 
 * addFlow and removeFlow methods.
 *
 */
abstract public class ExplicitOFConfigGen extends OFConfigGen{
    
    /**
     * Method that parses path, determines nodes in path then requests that 
     * the messages be generated by call addFlow or removeFlow. In general 
     * subclasses will not need to override this method.
     * 
     * @param action the setup or teardown action to be performed
     * @param nodeId the node to send the openflow messages
     */
    @Override
    public List<OFMessage> getOFConfig(PSSAction action, String nodeId) throws PSSException{
        List<OFMessage> results = new ArrayList<OFMessage>();
        ResDetails res = null;
        if(action.getActionType().equals(ActionType.SETUP)){
            res = action.getRequest().getSetupReq().getReservation();
        }else if(action.getActionType().equals(ActionType.TEARDOWN)){
            res = action.getRequest().getTeardownReq().getReservation();
        }
        List<CtrlPlaneHopContent> localHops;
        try {
            localHops = PathTools.getLocalHops(
                    res.getReservedConstraint().getPathInfo().getPath(), 
                    PathTools.getLocalDomainId());
        } catch (OSCARSServiceException e) {
            e.printStackTrace();
            throw new PSSException(e.getMessage());
        }

        //iterate through local hops
        List<CtrlPlaneHopContent> nodeHops = new ArrayList<CtrlPlaneHopContent>();
        for(CtrlPlaneHopContent hop : localHops){
            //get node id of hop
            String hopNodeId = null;
            try {
                hopNodeId = OFPathTools.extractNodeId(NMWGParserUtil.getURN(hop, NMWGParserUtil.NODE_TYPE));
            } catch (OSCARSServiceException e) {
                e.printStackTrace();
                throw new PSSException(e.getMessage());
            }

            //compare to current node
            if(!hopNodeId.equals(nodeId) && nodeHops.isEmpty()){
                continue;
            }else if(!hopNodeId.equals(nodeId)){
                //End of hops on node in this segment of path, so get messages
                if(action.getActionType().equals(ActionType.SETUP)){
                    results.addAll(this.addFlow(nodeHops.get(0), nodeHops.get(1), res));
                }else if(action.getActionType().equals(ActionType.TEARDOWN)){
                    results.addAll(this.removeFlow(nodeHops.get(0), nodeHops.get(1), res));
                }
                nodeHops = new ArrayList<CtrlPlaneHopContent>();
            }else{
                nodeHops.add(hop);
            }
        }
        //handle case where last hop in path
        if(!nodeHops.isEmpty()){
            //End of hops on node in this segment of path, so get messages
            if(action.getActionType().equals(ActionType.SETUP)){
                results.addAll(this.addFlow(nodeHops.get(0), nodeHops.get(1), res));
            }else if(action.getActionType().equals(ActionType.TEARDOWN)){
                results.addAll(this.removeFlow(nodeHops.get(0), nodeHops.get(1), res));
            }
        }


        return results;
    }
    
    /**
     * Stub method for generating a message to add a flow to an openflow device.
     * 
     * @param inHop the ingress link on a node
     * @param outHop the egress link on a node
     * @param reservation the reservation details
     * @return a list of OpenFlow messages to be sent to the device
     * @throws PSSException
     */
    abstract public List<OFMessage> addFlow(CtrlPlaneHopContent inHop, CtrlPlaneHopContent outHop, ResDetails reservation) throws PSSException;
    
    /**
     * Stub method for generating a message to remove a flow from an openflow device.
     * 
     * @param inHop the ingress link on a node
     * @param outHop the egress link on a node
     * @param reservation the reservation details
     * @return a list of OpenFlow messages to be sent to the device
     * @throws PSSException
     */
    abstract public List<OFMessage> removeFlow(CtrlPlaneHopContent inHop, CtrlPlaneHopContent outHop, ResDetails reservation) throws PSSException;

}
